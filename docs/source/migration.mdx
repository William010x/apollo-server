---
title: Migrating to Apollo Server 4 (Alpha)
---

> ⚠️ **Apollo Server 4 is out in public alpha.** It is not yet feature-complete, and breaking changes might occur between this release and general availability. [Learn about release stages.](https://www.apollographql.com/docs/resources/release-stages/#open-source-release-stages)
>
>  Apollo Server 4 introduces many across-the-board changes, and we are working on updating our documentation to reflect these changes. This article details all of the differences between Apollo Server 3 and Apollo Server 4.

> As the Apollo Server 4 rolls out we are in the process of bringing the rest of our documentation up to date. This migration guide covers all of the new changes between Apollo Server 3 and 4. Feel free to reference both the Apollo Server 3 docs in the meantime.

The focus of this major release is to improve Apollo Server's extensibility and make it simpler to use, maintain, and document. To learn more about the inspiration behind this release, see the [Apollo Server Roadmap](https://github.com/apollographql/apollo-server/blob/main/ROADMAP.md)

Apollo Server 4's alpha provides two of following features, with more to come with the full release:
<!-- TODO: fill in -->
- A simple well-defined API with a stable HTTP abstraction, enabling contributors to easily build integrations in other frameworks.
- Consistent context typing for TS users, ensuring


During Apollo Server 4's alpha, we are actively looking to gather feedback and [issues](https://github.com/apollographql/apollo-server/issues/new/choose) from community members and customers.

> For a list of all breaking changes, see the [changelog](https://github.com/apollographql/apollo-server/blob/main/CHANGELOG.md).

## Bumped dependencies

### Node.js
Apollo Server 4 supports Node.js 14 and later. This includes all [LTS and Current versions at the time of release](https://nodejs.org/en/about/releases/).

If you're using an older version of Node.js, upgrade your runtime before upgrading to Apollo Server 4.

### `graphql`

Apollo Server has a peer dependency on `graphql` (the core JS GraphQL implementation), which means you are responsible for choosing the version installed in your app.

Apollo Server 4 supports `graphql` v16.3.0 and later. (Apollo Server 3 supported `graphql` v15.3.0 through v16.)

If you're using an older version of `graphql`, upgrade it to a supported version before upgrading to Apollo Server 4.

## Removed integrations

Apollo Server 3 provided built-in framework integrations, attempting to make Apollo Server approachable for all developers regardless of their framework. Apollo Server 4 removes these built-in integrations, enabling developers to build and maintain their own integrations in the frameworks they know best.

Apollo Server 4 also removes the built-in dependency on the `cors` and `body-parser` libraries (minus the `startStandaloneServer` function), enabling developers to easily set up the middleware they need alongside their Apollo Server setup.

### Wrapping for framework-specific libraries

Apollo Server 3 is distributed as a [collection of different packages](/apollo-server/integrations/middleware) for different environments and web frameworks.

For [several reasons](https://github.com/apollographql/apollo-server/blob/main/ROADMAP.md#replace-9-core-maintained-bindings-with-a-stable-http-abstraction), these additional core-maintained integrations have caused friction in the development process and slowed down the Apollo Server team.

Apollo Server 4 replaces this static set of hard-coded integrations
with a stable API. Apollo Server 4's well-defined API enables collaborating developers to maintain and [build new integrations](/building-integrations) for the frameworks they know best.

Apollo Server 4 removes the below integration packages:
* "packages/apollo-server-fastify",
* "packages/apollo-server-hapi",
* "packages/apollo-server-koa",
* "packages/apollo-server-lambda",
* "packages/apollo-server-micro",
* "packages/apollo-server-cloud-functions",
* "packages/apollo-server-cloudflare",
* "packages/apollo-server-azure-functions",

> We are looking for volunteers to build and maintain these integrations! See the [issues with the 'integration-collaborators' label](https://github.com/apollographql/apollo-server/labels/integration-collaborators) to join the discussion about your favorite web framework today.


### `body-parser` & `cors` wrapping

Apollo Server 4 no longer wraps either the [`cors`](https://github.com/expressjs/cors) or [`body-parser`](https://www.npmjs.com/package/body-parser) libraries.

If you'd like to use either the `cors` or `body-parser` libraries, you can manually add both to your framework-specific middleware.

Below is an example of setting up `cors` and `body-parser` with Express:

<MultiCodeBlock>

```ts
import { ApolloServer, expressMiddleware } from '@apollo/server';
import express from 'express';
import http from 'http';
import cors from 'cors';
import bodyParser from 'body-parser';

const server = new ApolloServer({
  typeDefs,
  resolvers,
});

await server.start();
const app = express();
const httpServer = http.createServer(app);

// We set up our Express server's middleware:
// 1. using the `cors` and `body-parser` libraries, and
// 2. passing in an `ApolloServer` instance to the `expressMiddleware` function,
// attaching Apollo Server to our Express server
app.use(cors(), bodyParser.json(), expressMiddleware(server));
await new Promise<void>((resolve) => httpServer.listen({ port: 4000 }, resolve));

console.log(`🚀 Server ready at http://localhost:4000`);
```

</MultiCodeBlock>

Apollo Server 4's new [`startStandaloneServer`](#apolloserverstandalone-and-startstandaloneserver) function (e.g.,the replacement for the batteries-included `apollo-server` package) includes both the `body-parser` and `cors` packages under the hood, but neither package is configurable.

### Connect

[Connect](https://github.com/senchalabs/connect) is a predecessor of Express. Apollo Server 4 no longer supports Connect out of the box, though interested developers could write a connect-specific middleware using the Apollo Server 4 API. A PR to this migration guide is welcome if someone does this!

## Removed constructor options

The following `ApolloServer` constructor options have been removed in favor of other features or configuration methods.

### `dataSources`

In Apollo Server 3, the top-level [`dataSources` constructor option](/apollo-server/data/data-sources#adding-data-sources-to-apollo-server) was how  you provided `DataSource` subclasses to the [`context`](/apollo-server/data/resolvers/#the-context-argument) object.

In Apollo Server 4, we remove the `dataSources` constructor option to provide a more transparent way of adding `DataSource` subclasses to the `context` object for your server. This new way of adding `DataSource` subclasses also enables you to easily set up proper TypeScript typing for each data source.

<MultiCodeBlock>

```ts {35-44}
// Simple data source example
class DogsDataSource {
  constructor() {}

  async getDogs() {
    return [{ name: 'Fido' }];
  }
}

// Create a TS interface to ensure our dataSources are
// correctly typed
interface MyContext {
  dataSources: {
    dogs: DogsDataSource;
  }
}

// We create a new ApolloServer instance passing in our
// MyContext interface
const server = new ApolloServer<MyContext>({
  typeDefs: `
    type Query { dog: Dog }
    type Dog { name: String }
  `,
  resolvers: {
    Query: {
      dog: async (_, __, context) => {
        return (await context.dataSources.dogs.getDogs())[0];
      },
    },
  },
});

const { url } = await startStandaloneServer(server, {
  async context() {
    // This function is called for every incoming operation, and
    // will return the context object
    return {
      // Create a new instance of each data source for every operation
      dataSources: {
        dogs: new DogsDataSource(),
      },
    };
  },
  listen: { port: 4000 },
});

console.log(`Server ready at ${url}`);
```


```js {27-36}
// Simple data source example
class DogsDataSource {
  constructor() {}

  async getDogs() {
    return [{ name: 'Fido' }];
  }
}

// We create a new ApolloServer instance passing in our
// MyContext interface
const server = new ApolloServer({
  typeDefs: `
    type Query { dog: Dog }
    type Dog { name: String }
  `,
  resolvers: {
    Query: {
      dog: async (_, __, context) => {
        return (await context.dataSources.dogs.getDogs())[0];
      },
    },
  },
});

const { url } = await startStandaloneServer(server, {
  async context() {
    // This function is called for every incoming operation, and
    // will return the context object
    return {
      // Create a new instance of each data source for every operation
      dataSources: {
        dogs: new DogsDataSource(),
      },
    };
  },
  listen: { port: 4000 },
});

console.log(`Server ready at ${url}`);
```

</MultiCodeBlock>

In the above example, we create a `DogsDataSource` subclass and instantiate a new `DogsDataSource` within the object returned by the `context` function. With every incoming operation, the `context` function will return an object containing a new instance of `DogsDataSource` accessible to our resolvers from `context.dataSources.dogs`.

Expand the example below if you'd like to see how to set up a data source using the `RESTDataSource` class:

<ExpansionPanel title="Click to expand">

<MultiCodeBlock>

```ts
import { ApolloServer, startStandaloneServer } from '@apollo/server';
import { RESTDataSource } from 'apollo-datasource-rest';
import { KeyValueCache } from '@apollo/utils.keyvaluecache';

// RESTDataSource example
class BooksAPI extends RESTDataSource {
  private cache: KeyValueCache<string>;
  constructor(cache) {
    super();
    this.baseURL = 'https://the-one-api.dev/v2/';
    // initialize the data source with our cache
    this.initialize(cache);
  }

  async getBooks() {
    const { docs } = await this.get(`book/`);
    return docs;
  }
}

// Create a TS interface to ensure our dataSources are
// correctly typed
interface MyContext {
  dataSources: {
    booksAPI: BooksAPI;
  }
}

const server = new ApolloServer<MyContext>({
  typeDefs: `
    type Query { getBooks: [Book] }
    type Book { name: String _id: String }
  `,
  resolvers: {
    Query: {
      getBooks: async (_, __, context) => {
        return await context.dataSources.booksAPI.getBooks();
      },
    },
  },
});

const { url } = await startStandaloneServer(server, {
  async context() {
    return {
      dataSources: {
        booksAPI: new BooksAPI({ cache: server['internals'].cache }),
      },
    };
  },
  listen: { port: 4000 },
});

console.log(`Server ready at ${url}`);
```

</MultiCodeBlock>

</ExpansionPanel>

### `modules`
In Apollo Server 3, there are [several ways](https://github.com/apollographql/apollo-server/issues/6062) to provide your `ApolloServer` instance with a schema. One of these ways was using a `modules` constructor option, which  used the `buildServiceDefinition` function under the hood to specify a schema using an array of `typeDefs` and `resolvers` objects.

To simplify the Apollo Server 4 API, we removed the `modules` constructor option and recommend that developers use something like the following to create a schema:

```js
new ApolloServer({
  typeDefs: modules.map({ typeDefs } => typeDefs,
  resolvers: modules.map({ resolvers } => resolvers,
})
```

## Removed features

### Dropped support for older versions of the gateway

Apollo Server 4 drops support for [`@apollo/gateway` versions](/federation/api/apollo-gateway/) below v0.35.0.

#### Dropping Redundant Gateway TypeScript types

In Apollo Server 2, the TypeScript type used for the `gateway` constructor option is called `GraphQLService`. Apollo Server 3 introduced a new TypeScript type called `GatewayInterface`.

Apollo Server 4 will drop exporting the `SchemaChangeCallback` and `GraphQLService` types, we recommend using the `GatewayInterface` type instead.

This `GatewayInterface` requires the following:

- The `stop` method must be present.
- The `executor` method must async
- The `apollo` option must always be passed to the `load` method.

The `GraphQLExecutionResult` type (returned by `executor`) has been replaced by the similar `ExecutionResult` type from `graphql-js`. (The types are the same except that `data` and `extensions` are now `Record<string, unknown>` rather than `Record<string, any>`.)


### `__resolveObject`

Apollo Server 3 includes over nine core-maintained bindings for additional web frameworks and serverless environments.


### `formatResponse`

Removed `formatResponse` hook. The `willSendResponse` plugin API can accomplish similar goals. TODO show a replacement. TODO show example

### Remove features that wrap framework-specific libraries

<!-- TODO: expand and add links -->

Apollo Server 4 will replace a static set of hard-coded integrations
with a stable API which allows these integrations to be maintained by
people who actually run them in production.

One of the driving focuses behind Apollo Server 4 is creating a stable and well-defined API, enabling external developers who use to easily create and maintain integrations for new frameworks.

To that end, Apollo Server 4 removes the old integrations for now until the new integration packages are ready:
- "packages/apollo-server-fastify",
- "packages/apollo-server-hapi",
- "packages/apollo-server-koa",
- "packages/apollo-server-lambda",
- "packages/apollo-server-micro",
- "packages/apollo-server-cloud-functions",
- "packages/apollo-server-cloudflare",
- "packages/apollo-server-azure-functions",

> We are looking for volunteers to maintain these integrations! See the [issues with the 'integration-collaborators' label](https://github.com/apollographql/apollo-server/labels/integration-collaborators) to join the discussion about your favorite web framework today.

### Remove body-parser & CORS wrapping
In Apollo Server 4, framework integration functions won't try to wrap these basic framework-specific libraries. If you want to use our Express middleware, you'll be required to use the standard body-parser middleware yourself.

<!-- EXAMPLE OF Body parser and cors using express middleware -->
```ts
```


Apollo Server 4's new `startStandaloneServer` function(the replacement for the batteries-included `apollo-server` package) will still include both the `body-parser` and `cors` packages, but you can not configure those options.

### Removed health checks

In Apollo Server 3, the health check feature supported a simple HTTP-level health check that always returned the 200 status code.

In Apollo Server 4, we have removed the health checks feature. We found that running a trivial GraphQL query was a better way of checking the status of your server because a query ensures your server successfully serves traffic _and_ performs GraphQL operations.

Every GraphQL server supports a trivial query that requests the [`__typename`](/apollo-server/schema/schema/#the-__typename-field) of the top-level `Query` type.  This means every GraphQL server can respond to a `GET` request to a URL such as:

```bash
https://your.server/?query=%7B__typename%7D
```

If for some reason running this query is not an acceptable health check, folks integrating Apollo Server into a web framework can define their own health check via their web framework directly.

## Removed path parsing
Path parsing has been removed from Apollo Server 4. To further simplify the Apollo Server 4 API, if you'd like to mount your GraphQL server at a specified URL you can do so using your framework's specific middleware, like so:

### `__resolveObject`

If you want to run GraphQL on a non-root path, use your web framework’s functionality for mounting the middleware at the path. (Previously, the middlewares defaulted to only processing `/graphql`, and the g server processed all requests.)

### `formatResponse`
In Apollo Server 4 we removed the `formatResponse` hook. The `willSendResponse` plugin API can accomplish similar goals.

// TODO show a replacement. TODO show example


### Support for older gateway versions

Apollo Server 4 drops support for [`@apollo/gateway` versions](/federation/api/apollo-gateway/) below v0.35.0.

### Fields from `GraphQLRequestContext` and `GraphQLServiceContext`
In Apollo Server 4, the `debug` and `schemaHash` fields are no longer available on `GraphQLRequestContext`.

The `schemaHash` field was an unstable hash of the introspection JSON of a schema, created for the `apollo-server-plugin-operation-registry` package. Note that the `schemaHash` field is different from the hash of the schema SDL, which schema reporting uses.

We additionally removed the `persistedQueries` field from `GraphQLServiceContext`.

`GraphQLResponse` object (eg `requestContext.response`) has been refactored: the `data`, `errors`, and `extensions` fields are on a `result` sub-object. (This will change further for incremental delivery.) `data` and `extensions` are now `Record<string, unknown>` rather than `Record<string, any>` so more casts may be needed. `GraphQLRequestContext.response` and `GraphQLResponse.http` are now always set.

`requestDidStart` hooks are now called in parallel, rather than in series.

### Dropping Gateway TypeScript types

In Apollo Server 2, the TypeScript type used for the `gateway` constructor option is called `GraphQLService`. In Apollo Server 3, the TypeScript type is called `GatewayInterface`.

Apollo Server 4 drops the exports for both the `SchemaChangeCallback` and `GraphQLService` types. We recommend using the `GatewayInterface` type instead.

This `GatewayInterface` type requires the following:

- The `stop` method must be present.
- The `executor` method must async
- The `apollo` option must be passed to the `load` method.

The `GraphQLExecutionResult` type (returned by `executor`) has been replaced by the similar `ExecutionResult` type from `graphql-js`. (The types are the same except that `data` and `extensions` are now `Record<string, unknown>` rather than `Record<string, any>`.)

> All recent versions of `@apollo/gateway` satisfy these stronger requirements.

## Changes to framework integrations

Apollo Server 4 [removes built-in framework integrations](#removed-integrations) and fundamentally changes the Apollo Server API by no longer subclassing `ApolloServer`.


### Express API is now a function `expressMiddleware` instead of getMiddleware/applyMiddleware methods on a subclass of ApolloServer

<!-- link to /apollo-server/packages/server/src/express/index.ts -->
Moreover, there is no subclassing of ApolloServer at all.


As its name implies, you use the `expressMiddleware` function when setting up the middleware for your `Express` server. The `expressMiddleware` function accepts an `ApolloServer` instance:

<MultiCodeBlock>

```ts {15-16}
import express from 'express';
import http from 'http';
import cors from 'cors';
import { json } from 'body-parser';
// TODO: double-check this import
import { ApolloServer, expressMiddleware } from '@apollo/server';
import { typeDefs, resolvers } from ('./schema');

const server = new ApolloServer({
  typeDefs,
  resolvers,
});

await server.start();
// Pass the ApolloServer instance to the expressMiddleware function
app.use(cors(), json(), expressMiddleware(server));
await new Promise<void>((resolve) => httpServer.listen({ port: 4000 }, resolve));

console.log(`🚀 Server ready at http://localhost:4000`);
```

</MultiCodeBlock>

Additionally, the `expressMiddleware` function has no runtime dependency on `express` (or any other package).


### The `apollo-server` npm package is now the `startStandaloneServer` function

### `config` TypeScript name
In Apollo Server 4, the TypeScript name of the constructor options object has changed from `Config` to the more aptly named, `ApolloServerOptions`.

### `debug`

The `debug` constructor option has been renamed `includeStackTracesInErrorResponses`:

```ts

const apolloServerInstance = new ApolloServer<MyContext>({
  typeDefs,
  resolvers,
  includeStackTracesInErrorResponses: true,
});
```

<<<<<<< HEAD
const { url } = await startStandaloneServer(apolloServerInstance, {
  context: async ({req, _res}) => ({
    token: await getTokenForRequest(req),
  },
  listen: { port: 4000 },
});

## Changed Features


<<<<<<< HEAD
Note that you should only assume that the objects passed to your context function are http.IncomingMessage and http.ServerResponse objects, not necessarily their Express subclasses.
=======
=======
As part of this change, if you don't provide your own logger, the default log level has been changed to `DEBUG` (e.g., instead of `INFO`).

## Changed Features

<<<<<<< HEAD
###  `ApolloServerStandalone` and `startStandaloneServer`
Apollo Server 3 included a "batteries-included" version of `ApolloServer` designed to help developers get started quickly. This "batteries-included" version of `ApolloServer`  was less configurable, but included helpful defaults to reduce set up time.
>>>>>>> d8b77eefb (Start changed features)
<<<<<<< HEAD
>>>>>>> 736356c2f (Start changed features)
=======
=======
### `startStandaloneServer` function
Apollo Server 3 included a "batteries-included" `apollo-server` package, designed to help developers get started quickly. The "batteries-included" version of `ApolloServer`  was less configurable, but included helpful defaults to reduce set up time.
>>>>>>> 23ef9f211 (update from the version-4 branch)
>>>>>>> adfe5453c (update from the version-4 branch)

In Apollo Server 4, we introduce the `startStandaloneServer` function class in the main Apollo Server package which is similar in concept, but removes ambiguity and makes the name more easily reference-able.

Below is the syntax for setting up the `ApolloServerStandalone` class:

```js
// A TS interface for your context object, passed to ApolloServer upon instantiation
interface MyContext {
  token: String
}

const apolloServerInstance = new ApolloServer<MyContext>({
  typeDefs,
  resolvers,
});

// startStandaloneServer returns an ApolloServerStandalone instance.
// listenOpts accepts the same arguments as http.Server's listen() method
const { url } = await startStandaloneServer(apolloServerInstance, listenOpts, serverOpts)
```

Below is a snippet of the full set up for creating an instance of `ApolloServerStandalone`:

```ts
import { ApolloServer, startStandaloneServer } from "@apollo/server";
import { typeDefs, resolvers } from "./schema";

interface MyContext {
  token: string;
}

const apolloServerInstance = new ApolloServer<MyContext>({
  typeDefs,
  resolvers,
});

//
const { url } = await startStandaloneServer(apolloServerInstance, {
  context: async ({req, _res}) => ({
    token: await getTokenForRequest(req),
  }),
  listen: { port: 4000 }
}).listen({ port: 4000 });

console.log(`🚀 Server listening at: ${url}`);

```

The `startStandaloneServer` function from `@apollo/server` does have a runtime dependency on `express`.

### Renamed context

In AS3 we use `context` for both "a function producing a context value"
and "the context value itself".

<<<<<<< HEAD
In Apollo Server 4 we change this for clarity. `context` continues to be used as the name of the "a function producing a context value":
=======
In Apollo Server 4, `context` is the name of the "a function producing a context value":
>>>>>>> 23ef9f211 (update from the version-4 branch)

```ts
interface MyContext {
  token: string;
}

const apolloServerInstance = new ApolloServer<MyContext>({
  typeDefs,
  resolvers,
});

const { url } = await startStandaloneServer(apolloServerInstance, {
  context: async (req, _res) => ({
    token: await getTokenForRequest(req),
  }),
<<<<<<< HEAD
});

```

But any field containing a specific context value (such as on `GraphQLRequestContext`, the first argument to all plugin functions) is now named `contextValue`.
=======
})

```

Note, if you are accessing your context's _value_ in a plugin (e.g., on `GraphQLRequestContext`, or as a named argument to
`willResolveField`) you should now use `contextValue`.
>>>>>>> 23ef9f211 (update from the version-4 branch)

### `@apollo/utils.fetcher` for TypeScript typing

In Apollo Server 3 the `apollo-server-env` package primarily provided TypeScript typings and polyfills for the `fetch` and `URL` APIs. With Apollo Server 4, we created a new `@apollo/utils.fetcher` which defines a more minimal
fetch API as `Fetcher` to provide TypeScript typings.

You can now use `@apollo/utils.fetcher` instead of `apollo-server-env` to provide Fetch API TypeScript typing.

We are removing the `requestAgent` option from `ApolloServerPluginUsageReporting`, because this option predated the fetcher option.

So, instead of:
```ts
  ApolloServerPluginUsageReporting({ requestAgent })
```

You can now write:

```ts
    import fetch from 'node-fetch';
    ApolloServerPluginUsageReporting({
      fetcher: (url, options) => fetch(url, {
        ...options,
        agent: requestAgent,
      }),
    });
```

### Local landing page defaults to embedded
<<<<<<< HEAD

The default landing page for local development now is an embedded Apollo Sandbox which allows you to run operations with no CORS setup required. To return to the AS3 default of a splash page linking to Apollo Sandbox, pass `ApolloServerPluginLandingPageLocalDefault({embed: false})`.

### Error handling changes

#### Updates to ApolloError

TODO, see #6355.

#### Top-level error handling changes

Previously, some errors (mostly those that indicated the GraphQL operation was not being provided correctly over HTTP/JSON) were returned as `text/plain` error messages. Now all responses (other than landing pages) rendered by Apollo Server are `application/json` JSON responses; single-error responses are rendered as `{"errors":[{"message": "..."}]}` like any other GraphQL error. The `formatError` hook is used on all of these errors.

New plugin hooks `startupDidFail`, `contextCreationDidFail`, `invalidRequestWasReceived`, and `unexpectedErrorProcessingRequest` allow plugins to observe errors in new settings.

If `resolveOperation` or the `execute` function throws, the error will be rendered with HTTP status code 500 rather than 400. (Note that `execute` throwing is distinct from `execute` returning a non-empty list of errors, which is the more common case.)

### CSRF prevention (new in AS3.7) is on by default
By default, CSRF prevention is turned on in Apollo Server 4. For more information about CSRF prevention and CORS, see [Configuring CORS](/apollo-server/security/cors).
=======
The default landing page for local development now is an embedded Apollo Sandbox which allows you to run operations with no CORS setup required. To return to the AS3 default of a splash page linking to Apollo Sandbox, pass `ApolloServerPluginLandingPageLocalDefault({embed: false})`.

### CSRF prevention on by default
CSRF prevention was added to Apollo Server 3.7+, and is now on by default in Apollo Server 4. For more information about CSRF prevention and CORS, see [Configuring CORS](/apollo-server/security/cors).
>>>>>>> 23ef9f211 (update from the version-4 branch)

### ApolloServer’s generic argument is your context object type

Currently `ApolloServer` is genericized on the _arguments_ to the context function, rather the _actual_ context object itself. This means we don't get type inference into resolvers, inline plugins, etc.

Instead of passing context to the `ApolloServer` constructor at all, we choose to make it an _argument_ to the integration function. That way the arguments aren't genericized; they are specific to the function you're calling. Make the complete context object a parameter to the "execute this request' function.

We found a lot of places that `TContext` wasn't threaded through types and
added it.

Now you can do stuff like:

```ts
new ApolloServer<{ foo: number }>({
    Query: {
      n(_parent: any, _args: any, context): number {
        return context.foo;
      },
    },
  },
  plugins: [
    {
      async requestDidStart({ context }) {
        let n: number = context.foo;
      },
    },
    // Plugins declared to be <BaseContext> still work.
    ApolloServerPluginCacheControlDisabled(),
  ],
});
```

This also simplifies `executeOperation`, where you just pass a context
object directly instead of arguments to your context function.

<<<<<<< HEAD
### Context function is passed to your middleware-specific integration function (eg `expressMiddleware` or `startStandaloneServer`) instead of ApolloServer constructor

<<<<<<< HEAD
`ApolloServerBase` is now just `ApolloServer`. Context function is now a
named argument to the middleware; it's required if your context type is
not the default BaseContext.
=======
>>>>>>> d8b77eefb (Start changed features)
=======
### Context function passed to your middleware-specific integration function

`ApolloServerBase` is now just `ApolloServer`. The Context function is now a
named argument passed into your middleware; it's required if your context type is not the default `BaseContext`. ontext function is passed to your middleware-specific integration function (eg `expressMiddleware` or `startStandaloneServer`) instead of ApolloServer constructor
>>>>>>> 23ef9f211 (update from the version-4 branch)

Note that we differentiate in names between
"contextFunction" (a function returning a context object) and "context"
(the context object itself, eg as an argument to executeOperation).


#### `server.executeOperation` now takes a context *value* rather than arguments to pass to your context function.

This also simplifies executeOperation, where you just pass a context
object directly instead of arguments to your (probably already
fake-for-testing) context function.

We found that in practice, that’s what people actually wanted in tests. If you want to test the behavior of your context function, you can unit-test it directly.


### Combining packages into `@apollo/server`
Apollo Server 4 was designed to make a developer's experience simpler at every turn. To this end, Apollo Server 4 takes many previously separate npm packages and combines them all into a single `@apollo/server` package.

the following packages have all been incorporated into the `@apollo/server` package:
- `apollo-server-core`
- `apollo-server` (the "batteries-included" package)
- `apollo-server-express`
- `apollo-server-errors`
- `apollo-reporting-protobuf`
- `apollo-server-plugin-base`
- `apollo-server-types`


The `@apollo/server` naming is consistent with Apollo's other actively maintained npm packages (e.g., `@apollo/client` and `@apollo/gateway`). After Apollo Server 4 is released, all actively maintained Apollo packages will start with `@apollo/`; this leaves the `apollo-` namespace for other community integration packages like `apollo-server-fastify`.


### Change CacheScope enum to a pure type

<!-- In Apollo Server 4 the `CacheControlScope` enum has been changed into a union of strings type (`PUBLIC` or `PRIVATE`). This mean you can’t write `CacheScope.public` anymore
- The enum CacheScope is now union of strings type
  - (scope: CacheScope.Private -> scope: 'PRIVATE') -->

In Apollo Server 3, you can use the [`@cacheControl`](/apollo-server/performance/caching/#in-your-schema-static) to define caching behavior on a per-field basis. Under the hood, the `@cacheControl` directive uses a `CacheControlScope` enum.

Users will write 'PUBLIC' directly instead of `CacheScope.Public`. Note that if they are using TypeScript this is still perfectly type-safe (a typo will fail to compile); and if they're not using TypeScript, well misspelling `public` doesn't crash Node either, so perhaps they should use TypeScript if they care about such things.

```ts
enum CacheControlScope {
  PUBLIC
  PRIVATE
}
```


<<<<<<< HEAD
### Express API is now a function `expressMiddleware` instead of getMiddleware/applyMiddleware methods on a subclass of ApolloServer

<!-- link to /apollo-server/packages/server/src/express/index.ts -->
Moreover, there is no subclassing of ApolloServer at all.

`expressMiddleware` has no runtime dependency on `express` (or any other package) although `startStandaloneServer` does.

## Express middleware no longer tries to also work with Express’ predecessor project “Connect”

If anybody needs [Connect middleware](https://github.com/senchalabs/connect) they can add it themselves.


The `@apollo/server` naming is consistent with Apollo's other actively maintained npm packages (e.g., `@apollo/client` and `@apollo/gateway`). After Apollo Server 4 is released, all actively maintained Apollo packages will start with `@apollo/`; this leaves the `apollo-` namespace for other community integration packages like `apollo-server-fastify`.
=======
### HTTP handling changes
>>>>>>> 23ef9f211 (update from the version-4 branch)

`variables` and `extensions` should not be doubly-encoded

<<<<<<< HEAD
## HTTP handling changes

### `variables` and `extensions` should not be doubly-encoded

=======
>>>>>>> 23ef9f211 (update from the version-4 branch)
In JSON-encoded POST bodies, we expect variables and extensions (if provided) to be objects, not strings containing JSON strings of objects:

This works:
```
{“query”: “{ __typename }”, extensions: {“foo”: 1}}
```

And this does not:
```
{“query”: “{ __typename }”, extensions: “{\“foo\”: 1}”}
```

### HTTP batching as opt-in feature

Apollo Server supports [batching HTTP requests](/apollo-server/requests/#batching), which allows multiple GraphQL operations to be executed as part of a single HTTP request (sharing a single context function invocation as well).

In Apollo Server 3, support for HTTP batching was on by default. In Apollo Server 4, you must explicitly enable this feature by passing `allowBatchedHttpRequests: true` to the `ApolloServer` constructor.

<!-- TODO: investigate more! -->

### Plugin API changes

Remove schemaHash field from GraphQLRequestContext
This was a not particularly stable hash of the introspection JSON of a
schema. It was different from the hash of the schema SDL used by schema
reporting. It was created for the operation registry plugin but that
plugin hasn't used it for a while and it was only kept around for
backwards compatibility. So now it is gone.


Remove debug field from GraphQLRequestContext.

Remove persistedQueries field from GraphQLServerContext

`GraphQLResponse` object (eg `requestContext.response`) has been refactored: the `data`, `errors`, and `extensions` fields are on a `result` sub-object. (This will change further for incremental delivery.) `data` and `extensions` are now `Record<string, unknown>` rather than `Record<string, any>` so more casts may be needed. `GraphQLRequestContext.response` and `GraphQLResponse.http` are now always set.

requestDidStart hooks are called in parallel rather than in series.

## New APIs

### `addPlugin` function

Apollo Server 4 introduces a new public function on the `ApolloServer` class, `addPlugin`. The `addPlugin` function enables you to add plugins to `ApolloServer` _before_ you start a server (i.e., before calling `server.start()`).

```ts
import express from 'express';
import http from 'http';
import cors from 'cors';
import { json } from 'body-parser';
import { ApolloServer, ApolloServerPluginDrainHttpServer } from '@apollo/server';
// TODO: Double check this import
import { expressMiddleware } from '@apollo/server/express';
import { typeDefs, resolvers } from ('./schema');

const server = new ApolloServer({
  typeDefs,
  resolvers,
});

// Add our ApolloServerPluginDrainHttpServer plug in *before* starting the server
server.addPlugin(ApolloServerPluginDrainHttpServer({ httpServer }));

await server.start();
// Set up express middleware with body-parsing and cors
app.use(cors(), json(), expressMiddleware(server));
await new Promise<void>((resolve) => httpServer.listen({ port: 4000 }, resolve));

console.log(`🚀 Server ready at http://localhost:4000`);
```

The new `addPlugin` function is useful if you'd like to pass the server itself to a plugin’s constructor.

### `@apollo/server-plugin-operation-registry`
The plugin `apollo-server-plugin-operation-registry` has been renamed to `@apollo/server-plugin-operation-registry`.

### New HTTP request execution API
<!-- TODO: Figure out the final form of this -->
There’s a lot here :)

<<<<<<< HEAD
## Server lifecycle

### New approach to serverless frameworks

Instead of subclassing `ApolloServer` and overriding `serverlessFramework()` to return true, serverless integrations differentiate themselves from other integrations by calling `server.startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()`; other integrations expect the caller to first call `await server.start()` and validate this with `server.assertStarted()`.


### New warning when starting to execute an operation during shutdown

Apollo Server v3.2.0 added a "draining" phase to server shutdown which allows a server to complete in-progress operations before continuing to shut down. (This is set up automatically for you when using `startStandaloneServer` and can be configured with `ApolloServerPluginDrainHttpServer` when using `expressMiddleware` or other `http.Server`-based web servers.) If you do not drain your server, incoming operations can be sent to your server after it has already been stopped, which will fail. In Apollo Server 4, if a server receives an operation after the "draining" phase continues, it will log a warning encouraging you to set up draining before failing the operation.

=======
>>>>>>> 23ef9f211 (update from the version-4 branch)
### New API to support serverless frameworks
The main difference for Apollo Server between serverless and other
frameworks is that serverless frameworks typically need to provide a
request handler *synchronously* on startup. So our model of "you must
call `await server.start()` before your web server listens" doesn't
work.

The other minor differences are that the default value of
`stopOnTerminationSignals` is false for serverless integrations and the
default value of the usage reporting plugin's `sendReportsImmediately` is
`true` for serverless integrations; the latter was implemented via the
`serverlessFramework` option to the plugin `serverWillStart` API. In both
cases, this merely affected the default values and could be overridden
explicitly to true or false by the user.

The Apollo Sever 3 implementation was based on *subclassing* and overriding a
`serverlessFramework()` method; if this is true, the ApolloServer
constructor would start the startup process "in the background", logging
errors.

In AS4 we don't subclass `ApolloServer` at all.  Our new implementation
works by providing a synchronous alternative to `start()` called
`startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()`.
The length of the name is intended to discourage its use directly by app
writers when they are building non-serverless apps and `await
server.start()` is an option.

Calling this function works similarly to the implicit call at the end of
the AS3 serverless constructor. Additionally, it allows
`server.assertStarted()` to succeed even if startup is still ongoing.

The intended usage goes like this:

```ts
 await startStandaloneServer(server);
```

For a non-serverless middleware, the user should await `start()`. Note
that `expressMiddleware` itself calls `assertStarted`.

```ts
await server.start();
app.use(expressMiddleware(server));
app.listen();
```


For a serverless middleware (not implemented in core), the user doesn't
have to call any start-related function:
```ts
exports.handler = lambdaHandler(server);
```
The `lambdaHandler` function should call
`startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests`
for you.

In some cases, a serverless middleware might be implemented in terms of
a non-serverless middleware. For example, one approach to implementing
`lambdaHandler` would be to combine `expressMiddleware` with `express`
and `@vendia/serverless-express`. This is why we have the special case
that `assertStarted` (called by `expressMiddleware`) doesn't throw if
startup is currently taking place in the background.

We continue to have the default values of `stopOnTerminationSignals` and
`sendReportsImmediately` be influenced by whether you called start or
`startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests`. We
do change the `serverWillStart` option from `serverlessFramework` to
`startedInBackground`.

While we're at it, we added a new logged warning if any operations start
executing during the stopping or stopped phase encouraging users to use
a drain plugin.

Note: we add an invocation of the integration tests that combines Express
with this new API. That's not because we think people using Express should
use the API; it just means we were able to ensure that the tests could potentially work with the new API.  This helped us discover that (in the start-in-background case) `executeHTTPGraphQLRequest` throws rather than returns an error response if startup failed, which we should fix in a subsequent PR.

### New wrapper around `keyV`
We've decided to continue maintaining our own cache interface and instead offer a small wrapper around [`keyv`](https://www.npmjs.com/package/keyv) that users can choose to use themselves. This nicely guarantees our API regardless of the choices made by `keyv` (we just have to update the wrapper if anything changes).

`Cache` and `keyv` binding can now be found in the utils monorepo, published under the packages:

- `@apollo/utils.keyvaluecache`
- `@apollo/utils.keyvadapter`

We no longer maintain `apollo-server-cache-memcached` or `apollo-server-cache-redis`.

Existing implementations of `KeyValueCache` should continue to work.
- Mention that specifically redis users currently get a 300s default TTL, which will change when they move to Keyv. Our other cache implementations don't do this. This may or may not be worth mentioning since they should be reading the documentation for @keyv/redis when they make the switch and should configure it to their needs. But it wouldn't hurt to at least point it out.
- Mention that default cache is now bounded, `cache: 'bounded'` can be deleted

- Mention that specifically redis users currently get a 300s default TTL, which will change when they move to Keyv. Our other cache implementations don't do this. This may or may not be worth mentioning since they should be reading the documentation for @keyv/redis when they make the switch and should configure it to their needs. But it wouldn't hurt to at least point it out.

- Mention that default cache is now bounded, `cache: 'bounded'` can be deleted

#### Top-level error handling changes
Previously, some errors (mostly those that indicated the GraphQL operation was not being provided correctly over HTTP/JSON) were returned as `text/plain` error messages. Now all responses (other than landing pages) rendered by Apollo Server are `application/json` JSON responses; single-error responses are rendered as `{"errors":[{"message": "..."}]}` like any other GraphQL error. The `formatError` hook is used on all of these errors.
New plugin hooks `startupDidFail`, `contextCreationDidFail`, `invalidRequestWasReceived`, and `unexpectedErrorProcessingRequest` allow plugins to observe errors in new settings.
If `resolveOperation` or the `execute` function throws, the error will be rendered with HTTP status code 500 rather than 400. (Note that `execute` throwing is distinct from `execute` returning a non-empty list of errors, which is the more common case.)

## Server lifecycle

### New approach to serverless frameworks
Instead of subclassing `ApolloServer` and overriding `serverlessFramework()` to return true, serverless integrations differentiate themselves from other integrations by calling `server.startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()`; other integrations expect the caller to first call `await server.start()` and validate this with `server.assertStarted()`.


### New warning when starting to execute an operation during shutdown

Apollo Server v3.2.0 added a "draining" phase to server shutdown which allows a server to complete in-progress operations before continuing to shut down. (This is set up automatically for you when using `startStandaloneServer` and can be configured with `ApolloServerPluginDrainHttpServer` when using `expressMiddleware` or other `http.Server`-based web servers.) If you do not drain your server, incoming operations can be sent to your server after it has already been stopped, which will fail. In Apollo Server 4, if a server receives an operation after the "draining" phase continues, it will log a warning encouraging you to set up draining before failing the operation.



### Top-level errors consistent and observable
This change makes things more consistent by returning all errors as JSON
responses (using the `formatError` hook). In addition, for better
observability, several new top-level plugin APIs are introduced that are
called when various kinds of errors occur. Specifically:

- New plugin hook `startupDidFail`. This is called once if startup fails
  (e.g., if a 1serverWillStart1 plugin throws or if gateway fails to load
  the schema). (If this hook throws, its error is logged.) Future calls to
  1executeHTTPGraphQLRequest1 (if the server was started in the
  background) now return a formatted JSON error instead of throwing.

- New plugin hook `contextCreationDidFail`. (If this hook throws, its
  error is logged.) As before, these errors are sent as formatted JSON
  errors.

- New plugin hook `invalidRequestWasReceived`. This is called for all
  the errors that occur before being able to construct a GraphQLRequest
  from an `HTTPGraphQLRequest`; this includes things like the top-level
  fields being of the wrong type, missing body, CSRF failure, etc).
  These errors are now sent as formatted JSON instead of as text/plain.

- New plugin hook `unexpectedErrorProcessingRequest`. This is called if
  `processGraphQLRequest` throws (typically because a plugin hook
  threw). We are making the assumption that this means there is a
  programming error, so we are making the behavior change that the
  thrown error will be logged and "Internal server error" will be sent
  in the HTTP response.


# Upcoming Stuff to Cover:
- Move other plugins to their own repositories
- Change usage reporting defaults backwards-incompatibly to send less data
<<<<<<< HEAD
- Rethink ApolloError
- ApolloServer.logger should probably be public readonly in AS4
- Ensure errors thrown in context creation is handled in a helpful way
- Apollo Server plugins: expose server instance to plugins
- In general we just need to go over the full exported API and list what’s gone and where it’s gone. (This includes the re-export of `gql` from `graphql-tag`)

=======
- `ApolloServer.logger` should probably be public readonly in AS4
- In general we just need to go over the full exported API and list what’s gone and where it’s gone. (This includes the re-export of `gql` from `graphql-tag`)

### `apollo-datasource-rest` and `apollo-datasource`
Rename `apollo-datasource-rest` to `@apollo/datasource-rest`: ???

Rename `apollo-datasource` to `@apollo/datasource`: https://github.com/apollographql/apollo-datasource
>>>>>>> d8b77eefb (Start changed features)
